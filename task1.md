# 課題1  
## 実行方法  
コンパイルします  
```
$g++ task1.cpp -o task1
```
実行します  
```
$./task1
```
以下のように入力してenterキーを押します。  
```
Google 渋谷
```
5分ほど待ちますと以下のような出力が得られます。
```
Google->セグウェイ->渋谷
```
よって宿題1の答えはセグウェイを経由することで2回で辿れます。  
`Google 渋谷`ではなくても、任意の言葉の組み合わせで最短経路を出力できます。
例えば `雪見だいふく スノーボード`と入力すると`雪見だいふく->紅白->野球->スノーボード`と出力されます。
また、経路の存在しない言葉を入力すると`No Connection`という出力が得られ、wikiに存在しない言葉を入力すると`Invalid word`と表示されエラーになります。
task1.pyの方は`かもめの玉子 二分探索`と入力すると9分ほどで実行結果が得られます。
## コードの説明  
main関数内で使われている関数を上から順番に説明します。  
### read_pages(pages), read_links(links)
Yukiさんの配布してくださったコードそのままです。ファイルの読み込みをして、pages配列をlinks配列に入れます。  
### search_ID(start_page, goal_page, start_ID, goal_ID, pages)  
標準入力からはページ名を受け取るので、受け取った二つのページ名をページのIDに変換する関数です。  
for文でpages配列のページ名をひとつひとつ一致するものがないか愚直に見ていきます。一回のfor文で二つのページを探した方がページを1つずつ探すよ
り実行時間が短くなると思ったので少し関数が複雑になっています。ページが見つかると`already_searched`が1増えます。よってalready_searchedがfor文を
抜けた時に2になっていなかったらエラーを返します。  
## bfs_goal_ID
キューを用いてbfsをします。キューが空になるまたは探したいIDが見つかった時が終了点です。dfsではなくメモリ消費量の大きいbfsを選んだのは、最短経路を探し出すのに
行けるところまで深く行ってしまうbfsよりもstart地点に近いところを網羅的に探索してくれるbfsの方が実行時間が短くなると考えたからです。  
しかし、bfsの欠点として、経路を保存しておくことができません。解決策としてprevious_ID配列を用いて一つ前のIDを保存しておきます。これは、探索が重複しないように
することにも使えます(キーをmapに渡した時にすでに中身が入っていたら、探索済なので、これ以上進まない)。  
例えば```Google->セグウェイ->渋谷```だったら`previous_ID[渋谷のID]=セグウェイのID`、`previous_ID[セグウェイのID]=GoogleのID`です。  
探したいIDが見つかる前にキューが空になってしまったら、ルートが存在しないので、falseを返します。
## reverse_route 
一つ前の関数で作ったprevious_ID配列を用いて、ゴールとなるIDからスタートのIDまで、間を通るページのIDをroute配列に入れます。
## print_route
route配列を逆に辿れば、スタートからゴールまでに通るページのIDを順番に受け取れます。それをpagesを用いてIDからページ名に変換し、順次printします。
