# 考えられる理由  
## 1つ目　　　メモリ節約のため  
ハッシュテーブルにおいてO(1)での検索、追加、削除を実現するにはNよりも膨大な数のメモリを用意しておく必要がある。
なぜなら、Nに近い値の場合ハッシュ値が衝突しやすくなってしまい、そこに要素を付け加えていくと最悪O(N)になってしまう。
改善策であるハッシュが衝突したところに新たにハッシュを作っていこうとすると衝突が繰り返し起きた時にハッシュの構造が複雑になってしまう。  
ハッシュはメモリを確保していても使われないところが出てくる分メモリのコスパが木構造より悪い。  
## 2つ目     Nのオーダーが変わっても木構造では対応しやすいため  
ハッシュテーブルではNが増えてハッシュから溢れてしまった時、新たにハッシュを作り直すか、ハッシュが衝突したところに新たにハッシュを作る必要があり、
不便である。Nが膨大な時、新たにハッシュを作り直すのには大変な手間がかかる。その点木構造ではNが幾つになっても検索、追加、削除の手順は変わらず、
アルゴリズムを変えることなく使うことができる。
