# 課題1  
[予想](https://docs.google.com/document/d/1aYkRgIqQD0vaGqTiVQC_nJeYk3RjrZ9RIKulBvp5ABg/edit?usp=sharing)  
行列の大きさ512で計測  
|ループ順序|1回目(sec)|2回目(sec)|3回目(sec)|平均(sec)|
|--:|--:|--:|--:|--:|
|i-k-j|2.33|2.30|2.24|2.29|
|k-i-j|2.18|2.33|2.45|2.32|
|i-j-k|2.92|2.96|2.94|2.94|
|j-i-k|2.92|2.92|2.94|2.93|
|k-j-i|3.18|3.22|3.14|3.18|
|j-k-i|3.40|3.36|3.42|3.39|  

実行時間が早い順に<i,k,j>と<k,i,j>、<i,j,k>と<j,i,k>、<j,k,i>と<k,j,i>であるという予想は当たっていた。  
<i,k,j> < <k,i,j> << < <i,j,k> < <j,i,k> << < <k,j,i> < <j,k,i>　という予想は有意な差があるとは言えなさそうだった。  
# 課題2  
インタプリタ言語は構文木構造でaを配列としたとき、a[0]とa[1]は全くの別物として扱われ、隣り合ったメモリに確保される保証がない。よって行列の時も隣の数字がキャッシュに保存されている保証はなく、どのようにアクセスしても実行時間に変わりはなくなる。  
仮にインタプリタ言語もa[0]とa[1]が隣り合ったメモリに確保されキャッシュされるとする。  
インタプリタ言語はfor文の中を構文木で分解して一つ一つ見ていくので、コンパイラ言語と違って計算が最適化されていない。よって実行にものすごく時間がかかる。  
授業スライドによるとC++では1.8秒のところPythonでは18分であった。故に、メモリアクセスしたときのキャッシュによって削減される実行時間が微々たる量になる
。例えばC++にとっての1秒は結構大きい(55.6%)が、Pythonでは微々たる量(0.09%)である。よってインタプリタ言語ではi,k,jを入れ替えても実行時間はほとんど変わらない。
# 課題3  
### insert法  
まず二つの都市を決めて、ループさせる。その後に他の都市を順番に一番経路が近くなるような場所に順次挿入していく。  
<img width="682" alt="スクリーンショット 2021-06-29 9 10 01" src="https://user-images.githubusercontent.com/72332745/123718311-c9bba780-d8b9-11eb-8851-53f7ef73dbd0.png">
配列の真ん中のあたりに都市を挿入すると後ろの数字を全部ずらさないといけないので、計算時間を考慮して訪問都市の順序の管理には線形リストを用いることとした。
```
struct node{
    struct node *next;
    int city;
    double distance_to_next;
};
```
まず都市0と都市1のループを考えて、その後に都市2から順に、全ての場所に挿入して距離を計算し、一番短くなったところを訪問順とした。なお、都市数が1以下の時にはこのコードは動かない。
