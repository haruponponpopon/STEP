# 課題1  
[予想](https://docs.google.com/document/d/1aYkRgIqQD0vaGqTiVQC_nJeYk3RjrZ9RIKulBvp5ABg/edit?usp=sharing)  
行列の大きさ512で計測  
|ループ順序|1回目(sec)|2回目(sec)|3回目(sec)|平均(sec)|
|--:|--:|--:|--:|--:|
|i-k-j|2.33|2.30|2.24|2.29|
|k-i-j|2.18|2.33|2.45|2.32|
|i-j-k|2.92|2.96|2.94|2.94|
|j-i-k|2.92|2.92|2.94|2.93|
|k-j-i|3.18|3.22|3.14|3.18|
|j-k-i|3.40|3.36|3.42|3.39|  

実行時間が早い順に<i,k,j>と<k,i,j>、<i,j,k>と<j,i,k>、<j,k,i>と<k,j,i>であるという予想は当たっていた。  
<i,k,j> < <k,i,j> << < <i,j,k> < <j,i,k> << < <k,j,i> < <j,k,i>　という予想は有意な差があるとは言えなさそうだった。  
# 課題2  
インタプリタ言語は構文木構造でaを配列としたとき、a[0]とa[1]は全くの別物として扱われ、隣り合ったメモリに確保される保証がない。よって行列の時も隣の数字がキャッシュに保存されている保証はなく、どのようにアクセスしても実行時間に変わりはなくなる。  
仮にインタプリタ言語もa[0]とa[1]が隣り合ったメモリに確保されキャッシュされるとする。  
インタプリタ言語はfor文の中を構文木で分解して一つ一つ見ていくので、コンパイラ言語と違って計算が最適化されていない。よって実行にものすごく時間がかかる。  
授業スライドによるとC++では1.8秒のところPythonでは18分であった。故に、メモリアクセスしたときのキャッシュによって削減される実行時間が微々たる量になる
。例えばC++にとっての1秒は結構大きい(55.6%)が、Pythonでは微々たる量(0.09%)である。よってインタプリタ言語ではi,k,jを入れ替えても実行時間はほとんど変わらない。
# 課題3  
### insert法  
まず二つの都市を決めて、ループさせる。その後に他の都市を順番に一番経路が近くなるような場所に順次挿入していく。  
