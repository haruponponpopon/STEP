# 考えたこと  
初めに愚直に前から見ていくbest_fitとworst_fitを実装しました。 時間はかかりますが、best_fitのメモリ使用率に着目すると、 
best_fitが効率が良さそうです。  
best_fitを高速に実装することを目標として考えました。
|  first_fit ||  best_fit  ||  worst_fit  ||
| ---- | ---- |---- | ---- |---- | ---- |
|  11ms  |  70%  |  1797ms  |  70%  |  1766ms  |  70%  |
|  8ms  |  40%  |  789ms  |  40%  |  814ms  |  40%  |
|  148ms  |  7%  |  939ms  |  50%  |  91725ms  |  4%  |
|  39221ms  |  15%  |  15428ms  |  71%  |  927073ms  |  7%  |
|  31553ms  |  15%  |  10906ms  |  74%  |  807980ms  |  7%  |

best_fitは適合する最小のメモリ領域を探すので、まず初めに二分探索が候補に上がりました。first_fitでは構造体metadataはsizeとポインタnextを所持しますが、
nextの代わりにrightとleftのポインタを所持し、子ノードへのポインタとします。また、構造体my_heapのfree_headは常に一番上の親ノードを示すことで、
常にfree_headから、要件に見合う空き領域をlogNで探すことができます。  
親ノードを固定とする二分木で実際に実装してみましたが、うまくいかず、テストケースを見て、同じ数字がたくさん入ってくることに気がつきました。
同じ数字ばかり入ってくるとツリーはどこまでも下に伸びていってしまいます、、、愚直に計算するよりマシかもしれませんが、実装が大変な反面時間が短縮できません。
また、木を回転させると同じ数字の取り扱いが大変そうです。  
そこで、sizeは最大で5000弱という制約を見つけました。しかも8の倍数。これは辞書の出番です。空き領域8,16,24,,,と先頭のアドレスを配列に入れて、
残りはタグを用いたポインタ渡しでいけそうです。計算量は二分木と同じくらいかもしれませんが、実装が簡単そうです。
