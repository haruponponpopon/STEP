# 前回の復習  
ファイルのエラー処理はほどほどに行う  

座標(x,y)のときはArrayOfStructにすると処理がしやすい。(読み込みの時にStructOfArrayが書きやすかったのでそっちにしたら、逆にすればよかったと後々後悔しながらプログラムを記述していました、、、おっしゃる通りだと思います。)  

1行のbufferの変数名はlineが良い  

座標のリストのときは変数名は複数形  

入力が空の配列の可能性もあるので、その処理を記述するか空の配列は処理できない旨をdocumentに書く。  

size_tを適切に使うことでcaseせずに済む  
->先日vectorやstringですとsize_tの使い方がよくわからなくて、intにcastすることで.size()を使おうと思っていたのですが、具体的にvectorやstringのときはsize_tはどのように使えばよろしいのでしょうか。  

最小値を求めたい時は最小値を格納する変数に初めにものすごく大きな値を入れておくと比較回数が減る。  

交差しているかどうかではなくswapすることで距離が短くできるかという観点から攻めるとコードが簡単に書けるし計算時間も減る。  



# 考えたこと  
初めに愚直に前から見ていくbest_fitとworst_fitを実装しました。 時間はかかりますが、best_fitのメモリ使用率に着目すると、 
best_fitが効率が良さそうです。  
best_fitを高速に実装することを目標として考えました。
|  first_fit ||  best_fit  ||  worst_fit  ||
| ---- | ---- |---- | ---- |---- | ---- |
|  11ms  |  70%  |  1797ms  |  70%  |  1766ms  |  70%  |
|  8ms  |  40%  |  789ms  |  40%  |  814ms  |  40%  |
|  148ms  |  7%  |  939ms  |  50%  |  91725ms  |  4%  |
|  39221ms  |  15%  |  15428ms  |  71%  |  927073ms  |  7%  |
|  31553ms  |  15%  |  10906ms  |  74%  |  807980ms  |  7%  |

best_fitは適合する最小のメモリ領域を探すので、まず初めに二分探索が候補に上がりました。first_fitでは構造体metadataはsizeとポインタnextを所持しますが、
nextの代わりにrightとleftのポインタを所持し、子ノードへのポインタとします。また、構造体my_heapのfree_headは常に一番上の親ノードを示すことで、
常にfree_headから、要件に見合う空き領域をlogNで探すことができます。  
親ノードを固定とする二分木で実際に実装してみましたが、うまくいかず(ノードの削除の下りを間違えていました)、デバッグ中にテストケースを見て、同じ数字がたくさん入ってくることに気がつきました。
ノードの削除の下りがプログラムが煩雑になって訳がわからなくなってきたので方針を変えます。  
そこで、sizeは最大で4000という制約を見つけました。しかも8の倍数。これは辞書の出番です。空き領域8,16,24,,,と先頭のアドレスを配列に入れて、
残りはタグを用いたポインタ渡しで双方向リストを作成することでいけそうです。(うまくいきませんでした、、、)

### 以下のような辞書を用意する  
|  size |  先頭へのポインタ  |
| ---- | ---- |
| 0 | NULL |
| 8 | NULL |
| 16 | *a |
| 24 | NULL |
| 32 | NULL |
| 40 | *b |
| :  |  : |
| 4000 | NULL |

辞書(16)->a->c->d    
辞書(40)->b    
とポインタを渡していく  
タグには空き領域のサイズ、他の空き領域を指し示すnextとprevを持つ。  
メモリの中身
```
| データ | アドレスa size=16  next=*c, prev=辞書[16]| データ| アドレスb size=40 next=NULL prev=辞書[40]| データ | 
->続き|アドレスc size=16 next=*d, prev=*a| データ | アドレスd size=16 next=NULL, prev=*c|データ|
```

### 新しく空き領域が発生したら 
例えばsize 24のアドレスeの空き領域が発生したら、辞書のsize=24のところを*eにしてタグはsize=24, next=NULL, prev=辞書[24]とする。

辞書(16)->a->c->d   
辞書(24)->NULL  
辞書(40)->b  
↓  
辞書(16)->a->c->d   
辞書(24)->e  
辞書(40)->b 

例えばsize 16のアドレスfの空き領域が発生したら、辞書のsize=16のところを*fにしてタグはsize=16, next=*a, prev=辞書[16]とする。  
辞書(16)->a->c->d   
辞書(24)->NULL  
辞書(40)->b  
↓  
辞書(16)->f->a->c->d   
辞書(24)->e  
辞書(40)->b 

### 領域の削除  
例えばsize16、アドレスcの空き領域が削除されたら、空き領域cのタグにあるnextとprevを見る。next=*d, prev=*aなので
a->nextをdに、d->prevをaにする。    
辞書(16)->a->d    
辞書(40)->b   

例えばsize40、アドレスbの空き領域が削除されたら、空き領域bのタグにあるnextとprevを見る。next=NULL, prev=辞書[40]なので
辞書[40].先頭へのポインタ=NULLにする。    
辞書(16)->a->c->d    
辞書(40)->NULL   

例えばsize16、アドレスdの空き領域が削除されたら、空き領域dのタグにあるnextとprevを見る。next=NULL, prev=*cなので、c->nextを
NULLにする。  
辞書(16)->a->c->NULL    
辞書(40)->b   
